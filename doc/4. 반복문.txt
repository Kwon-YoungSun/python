4-1. 리스트와 반복문
* 리스트(list) : 여러가지 자료를 저장할 수 있는 자료
				0부터 세는 순서 있는 목록이다
예 ]
	>>> array = [273, 32, 103, "문자열", True, False]
	>>> print(array)
	[273, 32, 103, '문자열', True, False]

4-1-1. 리스트 선언하고 요소(element)에 접근하기
	
	생성 방법 ]
			[요소, 요소, 요소....]
	예 ]
		[273, 32, 103, '문자열', True, False]
		>>> [1,2,3,4]
		[1, 2, 3, 4]
		>>> ["안", "녕", "하", "세", "요"]
		['안', '녕', '하', '세', '요']
		>>> [273, 32, 103, "문자열", True, False]
		[273, 32, 103, '문자열', True, False]

리스트 각각의 요소는 배열의 형태로 저장되며, 인덱스 0부터 시작한다.
	>>> list_a = [273, 32, 103, "문자열", True, False]
	>>> list_a[0]
	273
	>>> list_a[1]
	32
	>>> list_a[2]
	103
	>>> list_a[1:3]
	[32, 103]

리스트의 특정 요소는 변경할 수도 있다.
	>>> list_a[0] = "변경"
	>>> list_a
	['변경', 32, 103, '문자열', True, False]

< 리스트의 다양한 사용법 >
1) 대괄호 안에 음수를 넣어 뒤에서부터 요소를 선택할 수도 있다.
	예 ]
		>>> list_a = [273, 32, 103, "문자열", True, False]
		>>> list_a[-1]
		False
		>>> list_a[-2]
		True
		>>> list_a[-3]
		'문자열'
		
		273		32		103		문자열	True	False
		[-6]	[-5]	[-4]	[-3]	[-2]	[-1]

2) 리스트 접근 연산자를 이중으로 사용할 수 있다.
	예 ]
		>>> list_a[3][0]
		'문'			<== list_a[3]의 "문자열"을 꺼내오고, "문자열"에서 다시 0번째 문자 "문"을 가져온다.

3) 리스트 안에 리스트를 사용할 수 있다.
	예 ]
		>>> list_a = [[1,2,3], [4,5,6], [7,8,9]]
		>>> list_a[1]
		[4, 5, 6]
		>>> list_a[1][1]
		5

참고 ] 리스트에서의 IndexError 예외
	>>> list_a = [273, 32, 103]
	>>> list_a[3]
==> 예외발생!!
Traceback (most recent call last):
  File "<pyshell#26>", line 1, in <module>
    list_a[3]
IndexError: list index out of range

---------------------------------------------------------------------------------------------------------------------------------------------------
4-1-2. 리스트 연산자: 연결(+), 반복(*), len()

	예 ]
		# 리스트를 선언합니다.
		list_a = [1,2,3]
		list_b = [4,5,6]

		# 출력합니다.
		print("# 리스트")
		print("list_a =", list_a)
		print("list_b =", list_b)
		print()

		# 기본 연산자
		print("# 리스트 기본 연산자")
		print("list_a + list_b =", list_a + list_b)
		print("list_a * 3 =", list_a * 3)
		print()

		# 함수
		print("# 길이 구하기")
		print("len(list_a) =", len(list_a))

		==> 실행 결과
		# 리스트
		list_a = [1, 2, 3]
		list_b = [4, 5, 6]

		# 리스트 기본 연산자
		list_a + list_b = [1, 2, 3, 4, 5, 6]    
		list_a * 3 = [1, 2, 3, 1, 2, 3, 1, 2, 3]

		# 길이 구하기
		len(list_a) = 3
------------------------------------------------------------------------------------------------------------------
*****
파괴적 함수와 비파괴적 함수의 차이점
	1. 비파괴적 함수 : upper, lower
		함수를 실행하기 전과 후가 값이 그대로 유지

	2. 파괴적 함수 : append, insert, extend
		함수를 실행하기 전과 후의 값이 달라짐
	
	왜 그렇게 만들었을까?
		대부분의 함수는 비파괴적 함수이다.
		개발 중의 실수를 줄이기 위해서는 비파괴적 함수가 좋다.
		그러나 리스트같은 자료형은 용량이 매우 크기 때문에
		프로그래밍 언어 입장에서 용량이 얼마나 큰지도 모르는 것을 '원본과 결과'라는
		두 가지로 생성하는 것은 위험할 수 있다. 따라서 파이썬 프로그래밍 언어는 원본을
		직접적으로 조작하는 기능을 제공해서 이러한 위험을 피하는 것이다.


4-1-3. 리스트에 요소 추가하기: append, insert
	형식 ]
		리스트명.append(요소)			==> 리스트 뒤에 요소 추가
		리스트명.insert(위치, 요소)		==> 지정 인덱스에 요소 추가	
	
	예 ]
		# 리스트를 선언합니다.
		list_a = [1,2,3]

		# 리스트 뒤에 요소 추가하기
		print("# 리스트 뒤에 요소 추가하기")
		list_a.append(4)
		list_a.append(5)

		print(list_a)
		print()

		# 리스트 중간에 요소 추가하기
		print("# 리스트 중간에 요소 추가하기")
		list_a.insert(0, 10)
		print(list_a)

		==> 실행 결과
		# 리스트 뒤에 요소 추가하기
		[1, 2, 3, 4, 5]

		# 리스트 중간에 요소 추가하기
		[10, 1, 2, 3, 4, 5]
	
	참고 ] extend() 함수
			한 번에 여러 요소를 추가하고 싶을 때 사용
			매개변수로 리스트를 입력하는데, 원래 리스트 뒤에 새로운 리스트의 요소를 모두 추가해줌
			예 ]
				>>> list_a = [1,2,3]
				>>> list_a.extend([4,5,6])
				>>> print(list_a)
				[1, 2, 3, 4, 5, 6]
				
	
	참고 ] 리스트 연결 연산자와 요소 추가의 차이
		예 ]	
			>>> list_a = [1,2,3]
			>>> list_b = [4,5,6]
			>>> list_a + list_b			==> 리스트 연결 연산자로 연결하니
			[1, 2, 3, 4, 5, 6]			==> 실행 결과로 [1,2,3,4,5,6] 이 나왔다
			>>> list_a
			[1, 2, 3]					==> list_a와 list_b에는 어떠한 변화도 없다.(비파괴적 처리)
			>>> list_b
			[4, 5, 6]
		예 ]
			>>> list_a = [1,2,3]
			>>> list_b = [4,5,6]
			>>> list_a.extend(list_b)	==> extend 함수로 연결하니 실행 결과로 아무것도 출력하지 않는다
			>>> list_a					==> list_a에 변화가 있다.(파괴적 처리)
			[1, 2, 3, 4, 5, 6]
			
		==> 리스트 연결 연산자( + )는 비파괴적 처리를 한다.
			반면 extend() 함수는 파괴적 처리를 한다.
		
		자료는 비파괴적으로 사용하는 것이 편리하다. 그러나 리스트는 용량이 매우 클 수도 있기 때문에
		리스트를 원본과 결과의 두 가지로 생성하는 것은 위험할 수도 있다.
		그래서, extend()와 같은 함수는 원본을 직접적으로 조작하는 기능을 제공해서 이러한 위험을 피한다.
		
-------------------------------------------------------------------------------------------------------------------------
4-1-4. 리스트에 요소 제거하기 : 크게 활용할 일은 없지만 사용할 일이 생길 수 있다
	1) 인덱스로 제거하기: del 키워드, pop() 메서드
		인덱스 위치를 기반으로 요소를 제거한다.
		형식 ]
				del 리스트명[인덱스]		<== 리스트의 특정 인덱스에 있는 요소 제거
				리스트명.pop(인덱스)		<== del과 동일. 매개변수를 입력하지 않으면 마지막 요소 제거
				
			예 ]
				list_a = [0,1,2,3,4,5]
				print("# 리스트의 요소 하나 제거하기")

				# 제거 방법[1] - del
				del list_a[1]
				print("del list_a[1]:", list_a)

				# 제거 방법[2] - pop()
				list_a.pop(2)
				print("pop(2):", list_a)
				
				==> 실행 결과
				# 리스트의 요소 하나 제거하기
				del list_a[1]: [0, 2, 3, 4, 5]
				pop(2): [0, 2, 4, 5]
				
			* pop()의 매개변수에 아무것도 입력하지 않으면 자동으로 -1이 들어가는 것으로 취급해서 마지막 요소를 제거한다.
			
		참고 ]
			del 키워드를 사용할 경우 범위를 지정해 리스트의 요소를 한꺼번에 제거할 수도 있다.
			예 ]
				>>> list_b = [0, 1, 2, 3, 4, 5, 6]
				>>> del list_b[3:6]
				>>> list_b
				[0, 1, 2, 6]
				
				>>> list_c = [0,1,2,3,4,5,6]
				>>> del list_c[3:]
				>>> list_c
				[0, 1, 2]

				>>> list_d = [0,1,2,3,4,5,6]
				>>> del list_d[:3]
				>>> list_d
				[3, 4, 5, 6]
				
	2) 값으로 제거하기: remove() 메서드
		값을 지정해서 요소를 제거한다. (오직 하나만 제거 가능)
		형식 ]
				리스트.remove(값)
				
			예 ]
				>>> list_c = [1,2,1,2]
				>>> list_c.remove(2)
				>>> list_c
				[1, 1, 2]
				==> 지정한 값이 리스트 내부에 여러 개 있어도 가장 먼저 발견되는 하나만 제거한다.
					만약 중복된 여러개 값을 모두 제거하려면 반복문과 조합해서 사용해야 한다.
					
	3) 모두 제거하기: clear
		리스트 내부의 요소를 모두 제거한다.
		형식 ]
			리스트.clear()
			
			예 ]
				>>> list_d = [0,1,2,3,4,5]
				>>> list_d.clear()
				>>> list_d
				[]
				
★ 지금까지의 모든 리스트의 함수들은 파괴적으로 동작한다.

--------------------------------------------------------------------------------------------------------------------------------
4-1-5. 리스트 내부에 있는지 확인하기: in/not in 연산자
	특정 값이 리스트 내부에 있는지 확인한다.
	
	형식 ]
		값 in 리스트
		값 not in 리스트
		not 값 in 리스트		<== 전체를 not 으로 감싸는 방법도 있으나 가독성을 위해 가급적 not in을 사용하자.
		
		예 ]
			>>> list_a = [273, 32, 103, 57, 52]
			>>> 273 in list_a
			True
			>>> 99 in list_a
			False
			>>> 100 in list_a
			False
			>>> 52 in list_a
			True
			
		예 ]
			>>> 273 not in list_a
			False
			>>> 99 not in list_a
			True
			>>> 52 not in list_a
			False
			>>> not 273 in list_a		
			False
			
-------------------------------------------------------------------------------------------------------------------------
4-1-6. for 반복문
	for <요소 변수 이름> in 리스트:
		코드
	
	예 ]
		for i in range(100):
			print("출력")
		==> 출력을 100번 반복한다
		
4-1-7. for 반복문: 리스트와 함께 사용하기
	형식 ]
		for 반복자 in 반복할 수 있는 것:
			코드
		==> 반복할 수 있는 것에는 문자열, 리스트, 딕셔너리, 범위 등이 있다
		
		예 ]
			# 리스트를 선언합니다.
			array = [273, 32, 103, 57, 52]

			# 리스트에 반복문을 적용합니다.
			for element in array:
				# 출력합니다.
				print(element)
			
			==> 실행결과
				273
				32
				103
				57
				52
	
	참고 ] for 반복문과 문자열
		for 반복문은 문자열을 함께 사용할 수도 있다.
		예 ]
			for character in "안녕하세요":
			print("-", character)
			
			==> 실행 결과
				- 안
				- 녕
				- 하
				- 세
				- 요
-------------------------------------------------------------------------------------------------------------------------
4-2. 딕셔너리와 반복문
	리스트는 인덱스를 기반으로 값을 저장한다. 반면에
	딕셔너리(Dictionary)는 '키를 기반으로 값을 저장하는 것'
	JAVA의 HashMap 또는 JSON과 비슷한 것 같다.
	
	예 ]
		{
			"키A": 10,
			"키B": 20,
			"키C": 30,
			1:	   40,
			False: 50
		}
	
	4-2-1 딕셔너리 선언하기
		형식 ]
			변수 = {
				키: 값,
				키: 값,
				...
				키: 값
			}
		
		예 ]
			>>> dict_a = {
			"name": "어벤저스 앤드게임",
			"type": "히어로 무비"
			}
			
	4-2-2. 딕셔너리의 요소에 접근하기
		>>> dict_a
		{'name': '어벤저스 앤드게임', 'type': '히어로 무비'}
		
		딕셔너리의 특정 요소에 접근할 때는 딕셔너리 뒤에 대괄호를 입력하고, 내부에 키 값을 입력한다.
		>>> dict_a["name"]
		'어벤저스 앤드게임'
		>>> dict_a["type"]
		'히어로 무비'
		
		예 ]
			>>> dict_b = {
				"director": ["안소니 루소", "조 루소"],
				"cast": ["아이언맨", "타노스", "토르", "닥터스트레인지", "헐크"]
				}
			>>> dict_b["director"]
			['안소니 루소', '조 루소']
			
		< 딕셔너리의 문자열 키와 관련된 실수 >
			>>> dict_key = {
				name: "7D 건조 망고",
				type: "당절임"
				}
			Traceback (most recent call last):
			  File "<pyshell#18>", line 2, in <module>
				name: "7D 건조 망고",
			NameError: name 'name' is not defined
			==> "name", "type" 으로 수정해야 한다
	
	4-2-3. 딕셔너리에 값 추가하기/제거하기
		형식 ]
				추가 : 딕셔너리[새로운 키] = 새로운 값
				삭제 : del 딕셔너리[기존 키]
				
		예 ]
			 dictionary = {
				"name": "7D 건조 망고",
				"type": "당절임",
				"ingredient": ["망고", "설탕", "메타중아황산나트륨", "치자황색소"],
				"origin": "필리핀"
			}
			>>> dictionary["price"] = 5000		# 값 추가
			>>> dictionary
			{'name': '7D 건조 망고', 'type': '당절임', 'ingredient': ['망고', '설탕', '메타중아황산나트륨', '치자황색소'], 'origin': '필리핀', 'price': 5000}
		
		예 ]
			del dictionary["ingredient"]		# 값 제거
			>>> dictionary
			{'name': '7D 건조 망고', 'type': '당절임', 'origin': '필리핀', 'price': 5000}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	*** 딕셔너리에 안전하게 접근하기 위해서 사용하는 함수로 코딩 시 많이 사용됨
	4-2-4. 딕셔너리 내부에 키가 있는지 확인하기
		1) in 키워드
			형식 ]
				키값 in 딕셔너리
				
			예 ]
				# 딕셔너리를 선언합니다.
				dictionary = {
					"name": "7D 건조 망고",
					"type": "당절임",
					"ingredient": ["망고", "설탕", "메타중아황산나트륨", "치자황색소"],
					"origin": "필리핀"
				}
				# 사용자로부터 입력을 받습니다.
				key = input("> 접근하고자 하는 키: ")

				# 출력합니다.
				if key in dictionary:			# in 키워드 사용
					print(dictionary[key])
				else:
					print("존재하지 않는 키에 접근하고 있습니다.")
					
		2) get() 함수
			형식 ]
				딕셔너리.get("키값")
				딕셔너리.get("키값")[인덱스넘버]
				
			예 ]
				# 존재하지 않는 키에 접근해 봅니다.
				value = dictionary.get("존재하지 않는 키")
				print("값:", value)

				# None 확인 방법
				if value == None:
					print("존재하지 않는 키에 접근했습니다.")
					
				==> 실행 결과
					값: None
					존재하지 않는 키에 접근했습니다.
					
	4-2-5. for 반복문: 딕셔너리와 함께 사용하기
		형식 ]
			for 키 변수 in 딕셔너리:
				코드
				
		예 ]
			# 딕셔너리를 선언합니다.
			dictionary = {
				"name": "7D 건조 망고",
				"type": "당절임",
				"ingredient": ["망고", "설탕", "메타중아황산나트륨", "치자황색소"],
				"origin": "필리핀"
			}

			# for 반복문을 사용합니다.
			for key in dictionary:
				# 출력합니다.
				print(key, ":", dictionary[key])
				
			==> 실행 결과
				name : 7D 건조 망고
				type : 당절임
				ingredient : ['망고', '설탕', '메타중아황산나트륨', '치자황색소']
				origin : 필리핀
-------------------------------------------------------------------------------------------------------------------------------------------------
4-3. 반복문과 while 반복문
4-3-1. 범위(range) 자료형
	range(시작, 끝, 단계)
		예 ] list(range(0, 10, 1))
			==> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	** 끝 범위는 반영하지 않음

	1) 매개변수에 숫자를 한 개 넣는 방법
		0부터 A-1까지의 정수로 범위를 만든다.
			range(A)		==> A는 숫자

	2) 매개변수에 숫자를 두 개 넣는 방법
		A부터 B-1까지의 정수로 범위를 만든다.			
			range(A, B)	==> A와 B는 숫자

	3) 매개변수에 숫자를 세 개 넣는 방법
		A부터 B-1까지의 정수로 범위를 만드는데, 앞뒤의 숫자가 C만큼의 차이를 가진다.
			range(A, B, C)	==> A, B, C는 숫자

	예 ]
		>>> a = range(5)
		>>> a
		range(0, 5)						
		>>> list(range(10))
		[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
		>>> list(range(0, 5))			==> 0부터 (5-1)까지의 정수로 범위를 만든다.
		[0, 1, 2, 3, 4]
		>>> list(range(5,10))			==> 5부터 (10-1)까지의 정수로 범위를 만든다.
		[5, 6, 7, 8, 9]
		
		>>> list(range(0, 10, 2))		==> 0부터 2씩 증가하면서 (10-1)까지의 정수로 범위를 만든다.
		[0, 2, 4, 6, 8]
		>>> list(range(0, 10, 3))		==> 0부터 3씩 증가하면서 (10-1)까지의 정수로 범위를 만든다.
		[0, 3, 6, 9]
		
		>>> a = range(0, 10 + 1)		==> 범위를 만들 때 매개변수 내부에 수식을 사용하는 경우
		>>> list(a)
		[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		
		주의 ]
			>>> n = 10
			>>> a = range(0, n/2)
				==> 에러발생!! 매개변수로 나눗셈을 사용한 경우 오류가 발생한다.
					range() 함수의 매개변수로는 반드시 정수를 입력해야 한다.
			
			>>> a = range(0, int(n / 2))		==>	실수를 정수로 바꾸는 방법보다
			>>> list(a)
			[0, 1, 2, 3, 4]
			
			>>> a = range(0, n//2)				==> 정수 나누기 연산자를 많이 사용한다.
			>>> list(a)
			[0, 1, 2, 3, 4]
			
4-3-2. for 반복문: 범위와 함께 사용하기
	for 숫자변수 in 범위:
		코드
		
	예 ]
		for i in range(0, 10, 3):
			print(str(i) + "= 반복 변수")
		print()

	==> 
		0= 반복 변수
		3= 반복 변수
		6= 반복 변수
		9= 반복 변수
		
4-3-3. for 반복문: 리스트와 범위 조합하기
	예 ] 
		# 리스트를 선언합니다.
		array = [273, 32, 103, 57, 52]

		# 리스트에 반복문을 적용합니다.
		for i in range(len(array)):
			# 출력합니다.
			print("{}번째 반복: {}".format(i, array[i]))
			
		==> 실행 결과
			0번째 반복: 273
			1번째 반복: 32
			2번째 반복: 103
			3번째 반복: 57
			4번째 반복: 52
			
4-3-4. for 반복문: 반대로 반복하기
	1) 범위를 -1로 지정
		# 역반복문
		for i in range(4, 0-1, -1):				==> -1로 입력해도 상관없지만 0까지 반복한다는 것을 강조하기 위해서 사용한 코드임
			# 출력합니다.
			print("현재 반복 변수: {}".format(i))
			
		==> 실행 결과
		현재 반복 변수: 4
		현재 반복 변수: 3
		현재 반복 변수: 2
		현재 반복 변수: 1
		현재 반복 변수: 0
	
	2) reversed 함수 사용
		for i in reversed(range(5)):
			# 출력합니다.
			print("현재 반복 변수: {}".format(i))

----------------------------------------------------------------------------------------------------------------------------------
4-3-5. while 반복문
	while 불 표현식:
		문장

4-3-6. while 반복문: for 반복문처럼 사용하기
	예 ]
		i = 0
		while i < 10:
			print("{}번째 반복입니다.".format(i))
			i += 1
		==> 실행 결과
		0번째 반복입니다.
		1번째 반복입니다.
		2번째 반복입니다.
		3번째 반복입니다.
		4번째 반복입니다.
		5번째 반복입니다.
		6번째 반복입니다.
		7번째 반복입니다.
		8번째 반복입니다.
		9번째 반복입니다.
		
	참고 ] while 반복문의 사용 용도
		for 반복문에서 구현할 수 없는 무한반복을 구현하고자 할 때
		조건을 활용해서 반복을 사용해야 할 때(조건이 중요한 경우)
		
4-3-7. while 반복문: 상태를 기반으로 반복하기
	참고 ] 유닉스 타임
		세계 표준시(UTC), 1970년 1월 1일 0시 0분 0초를 기준으로 몇 초가 지났는지를 정수로 나타낸 것이다.
		<파이썬에서 유닉스 타임 구하기>
			>>> import time
			>>> time.time()
			1614233131.5258925
			
	예 ] 5초 동안 반복하기
		# 시간과 관련된 기능을 가져온다.
		import time

		# 변수를 선언한다.
		number = 0

		# 5초 동안 반복한다.
		target_tick = time.time() + 5
		while time.time() < target_tick:
			number += 1

		# 출력한다.
		print("5초 동안 {}번 반복했습니다.".format(number))
		
		==> 실행 결과
			5초 동안 47926761번 반복했습니다.
			
4-3-8. while 반복문: break 키워드/continue 키워드
	- break		: 반복문 탈출
	- continue	: 반복문 반복	==> 들여쓰기 단계를 줄이고자 할 때 사용
===================================================================================================
4-4. 문자열, 리스트, 딕셔너리와 관련된 기본 함수
4-4-1. 리스트에 적용할 수 있는 기본 함수: min(), max(), sum()
	- min()		: 리스트 내부에서 최솟값을 찾는다.
	- max()		: 리스트 내부에서 최댓값을 찾는다.
	- sum()		: 리스트 내부에서 값을 모두 더한다.
	
	예 ]
		>>> numbers = [103, 52, 273, 32, 77]
		>>> min(numbers)
		32
		>>> max(numbers)
		273
		>>> sum(numbers)
		
	참고 ] 리스트를 사용하지 않고 최솟값, 최댓값 구하기
		>>> min(103, 52, 273)
		52
		>>> max(103, 52, 273)
		273

---------------------------------------------------------------------------------------------------------------------------
*** 일회용 함수 : 제너레이터

4-4-2. reversed() 함수로 리스트 뒤집기
	예 ]
		# 리스트를 선언하고 뒤집는다.
		list_a = [1,2,3,4,5]
		list_reversed = reversed(list_a)

		# 출력한다.
		print("# reversed() 함수")
		print("reversed([1,2,3,4,5]):", list_reversed)
		print("list(reversed([1,2,3,4,5]))", list(list_reversed))
		print()

		# 반복문을 적용해 본다.
		print("# reversed() 함수의 반복문")
		print("for i in reversed([1,2,3,4,5]):")
		for i in reversed(list_a):
			print("-", i)
			
		==> 실행 결과
			# reversed() 함수
			reversed([1,2,3,4,5]): <list_reverseiterator object at 0x0000024F8C241FD0>	==> 이터레이터 공부
			list(reversed([1,2,3,4,5])) [5, 4, 3, 2, 1]

			# reversed() 함수의 반복문
			for i in reversed([1,2,3,4,5]):
			- 5
			- 4
			- 3
			- 2
			- 1
			
	주의 ] reversed() 함수의 결과는 제너레이터이기 때문에 
			reversed() 함수와 반복문을 조합할 때는, for 구문 내부에 reversed() 함수를 곧바로 넣어서 사용하자.
		
		예 ]
			temp = reversed([1,2,3,4,5,6])

			for i in temp:
				print("첫 번째 반복문: {}".format(i))

			for i in temp:
				print("두 번째 반복문: {}".format(i))
			
			==> 첫 번째 반복문만 출력된다.
				reversed() 함수는 제너레이터이기 때문이다.
		
		예 ]
			numbers = [1,2,3,4,5,6]

			for i in reversed(numbers):
				print("첫 번째 반복문: {}".format(i))

			for i in reversed(numbers):
				print("두 번째 반복문: {}".format(i))
			==> 첫번째, 두번째 반복문 모두 출력된다.
			
	참고 ] 확장 슬라이싱
		리스트를 뒤집는 또 다른 방법
		다음과 같이 리스트에 [::-1]을 붙이면 리스트의 내용이 뒤집힌다.
		
		예 ]
			>>> numbers = [1,2,3,4,5]
			>>> numbers
			[1, 2, 3, 4, 5]
			>>> numbers[::-1]
			[5, 4, 3, 2, 1]
		
		==> 비파괴적 코드이므로 원본 numbers에는 영향이 없다. 또한 문자열에도 적용 가능하다.
		
		예 ]
			>>> "안녕하세요"[::-1]
			'요세하녕안'


4-4-3. enumerate() 함수와 반복문 조합하기
	리스트의 요소를 반복할 때, 현재 인덱스가 몇 번째인지 확인해야 하는 경우 사용한다.
	
	예 ]
		# 변수를 선언합니다.
		example_list = ["요소A", "요소B", "요소C"]

		# 그냥 출력합니다.
		print("# 단순 출력")
		print(example_list)
		print()

		# enumerate() 함수를 적용해 출력합니다.
		print("# enumerate() 함수 적용 출력")
		print(enumerate(example_list))
		print()

		# list() 함수로 강제 변환해 출력합니다.
		print("# list() 함수로 강제 변환 출력")
		print(list(enumerate(example_list)))

		# for 반복문과 enumerate() 함수 조합해서 사용하기
		print("# 반복문과 조합하기")
		for i, value in enumerate(example_list):
			print("{}번째 요소는 {}입니다.".format(i, value))
			
		==> 실행 결과
			# 단순 출력
			['요소A', '요소B', '요소C']

			# enumerate() 함수 적용 출력
			<enumerate object at 0x0000029E4211D5C0>		==> 이터레이터

			# list() 함수로 강제 변환 출력
			[(0, '요소A'), (1, '요소B'), (2, '요소C')]
			# 반복문과 조합하기
			0번째 요소는 요소A입니다.
			1번째 요소는 요소B입니다.
			2번째 요소는 요소C입니다.
--------------------------------------------------------------------------------------------------------------------------------
4-4-4. 딕셔너리의 items() 함수와 반복문 조합하기
	예 ]
		# for 반복문과 items() 함수 조합해서 사용하기
		print("# 딕셔너리의 items() 함수와 반복문 조합하기")

		for key, element in example_dictionary.items():
			print("dictionary[{}] = {}".format(key, element))
			
		==> 실행 결과
		
			# 딕셔너리의 items() 함수와 반복문 조합하기
			dictionary[키A] = 값A
			dictionary[키B] = 값B
			dictionary[키C] = 값C
------------------------------------------------------------------------------------------------------------------------------------------			
4-4-5. 리스트 내포
	반복문을 사용해 리스트를 재조합하는 방법을 파이썬에서는 훨씬 간결하게 할 수 있다.
	형식 ]
		리스트 이름 = [표현식 for 반복자 in 반복할 수 있는 것 if 조건문]
		
	예 ]
		# 리스트를 선언합니다.
		array = [i * i for i in range(0, 20, 2)]		# range(0, 20, 2)의 요소를 i라고 할 때 i*i로 리스트를 재조합해 주세요
				==> 최종 결과(i*i)를 앞에 작성한다.

		# 출력합니다.
		print(array)
		
		==> 출력 결과
			[0, 4, 16, 36, 64, 100, 144, 196, 256, 324]
			
	< if 구문을 포함한 리스트 내포 >
	형식 ]
		리스트 이름 = [표현식 for 반복자 in 반복할 수 있는 것 if 조건문]
---------------------------------------------------------------------------------------------------------------------------------
< 괄호로 문자열 연결하기 >
	예 ]
		# 변수를 선언합니다.
		test = (
			"이렇게 입력해도 "
			"하나의 문자열로 연결되어 "
			"생성됩니다."
		)

		# 출력합니다.
		print("test:", test)
		print("type(test):", type(test))
		==> 출력 결과
			test: 이렇게 입력해도 하나의 문자열로 연결되어 생성됩니다.
			type(test): <class 'str'>
		
	참고 ] 튜플 자료형과의 구분
		튜플 자료형은 괄호 내부의 문자열이 쉼표로 연결되어야 한다.
		test = (
			"쉼표로 연결하면 ",
			"문자열이 아니라 ",
			"튜플이 생성된다."
		)
	
< 문자열의 join() 함수 >
	문자열.join(문자열로 구성된 리스트)
	예 ]
		>>> print("::".join(["1", "2", "3", "4", "5"]))
		1::2::3::4::5
---------------------------------------------------------------------------------------------------------------------------------
참고 ] 이터레이터
	'반복할 수 있는 것'을 프로그래밍 용어로 이터러블(iterable) 이라고 한다.
	즉 이터러블은 내부에 있는 요소들을 차례차례 꺼낼 수 있는 객체를 의미(리스트, 딕셔너리, 문자열 튜플)
	
	예 ]
		# 변수를 선언합니다.
		numbers = [1,2,3,4,5,6]
		r_num = reversed(numbers)	<== 이터레이터
		
		# reversed_numbers 를 출력합니다.
		print("reversed_numbers :", r_num)
		print(next(r_num))
		print(next(r_num))
		print(next(r_num))
		print(next(r_num))
		print(next(r_num))
		
		==> 실행 결과
			reversed_numbers : <list_reverseiterator object at 0x000001EC4FBE1FD0>
			6
			5
			4
			3
			2
		
		이터레이터는 반복문의 매개변수로 전달할 수 있고, next() 함수로 내부의 요소를 하나하나 꺼낼 수 있다.

----------------------------------------------------------------------------------------------------------------------------------
< 2진수, 8진수, 16진수로 변환하는 코드 >
	1) 10진수와 2진수 변환
		예 ]
			>>> "{:b}".format(10)
			'1010'
			>>> int("1010", 2)
			10
		
	2) 10진수와 8진수 변환
		예 ]
			>>> "{:o}".format(10)
			'12'
			>>> int("12", 8)
			10
			
	3) 10진수와 16진수 변환
		예 ]
			>>> "{:x}".format(10)
			'a'
			>>> int("10", 16)
			16
	
	bin(), oct(), hex() 라는 함수를 사용하는 방법도 있지만 format() 함수를 사용하는 방법이 유연하다.

< 반복 가능한 객체(문자열, 리스트, 범위 등)의 count() 함수
	>>> "안녕안녕하세요".count("안")	==> 문자열을 매개변수로 넣어야 한다.
================================================================================================================
*** 형태를 반드시 암기하자
min(리스트) or min(숫자, 숫자, 숫자, ...)
max(리스트) or max(숫자, 숫자, 숫자, ...)
sum(리스트)
for i in reversed(리스트):
for i, element in enumerate(리스트):
for key, value in 딕셔너리.items():