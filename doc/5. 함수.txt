5. 함수
5-1. 함수 만들기
	5-1-1. 함수의 기본
		
		def 함수이름():
			문장
	
		예 ]
			def print_3_times():
				print("안녕하세요")
				print("안녕하세요")
				print("안녕하세요")

			print_3_times()
			
			==> 실행 결과
			
				안녕하세요
				안녕하세요
				안녕하세요
				
	5-1-2. 함수에 매개변수 만들기
		형식 ]
			def 함수 이름(매개변수, 매개변수, ...):
				문장
			
		예 ]
			def print_n_times(value, n):
				for i in range(n):
					print(value)

			print_n_times("안녕하세요", 5)
			==> 실행 결과
			
				안녕하세요
				안녕하세요
				안녕하세요
				안녕하세요
				안녕하세요
				
	< 매개변수와 관련된 TypeError >
		함수를 호출할 때 매개변수를 넣지 않거나 더 많이 넣으면 오류를 출력한다.
	
	5-1-3. 가변 매개변수
		형식 ]
			def 함수 이름(매개변수,매개변수, ..., *가변 매개변수):
				문장
			
		- 가변 매개변수 뒤에는 일반 매개변수가 올 수 없다.
		- 가변 매개변수는 하나만 사용할 수 있다.
		
		예 ]
			def print_n_times(n, *values):
				# n번 반복합니다.
				for i in range(n):
					# values는 리스트처럼 활용합니다.
					for value in values:
						print(value)
					# 단순한 줄바꿈
					print()

			# 함수를 호출합니다.
			print_n_times(3, "안녕하세요", "즐거운", "파이썬 프로그래밍")
	
	5-1-4. 기본 매개변수
		* print() 함수의 자동 완성 기능으로 나오는 설명
		print(*values: object, sep: Optional[Text]=..., end: Optional[Text]=..., file: Optional[_Writer]=..., flush: bool=...)
		
		'매개변수=값' 형태로 되어 있다. 이는 매개변수를 입력하지 않았을 경우 매개변수에 들어가는 기본값이다.
		
		- 기본 매개변수 뒤에는 일반 매개변수가 올 수 없다.
		
		예 ]
			def print_n_times(value, n=2):
				# n번 반복합니다.
				for i in range(n):
					print(value)

			# 함수를 호출합니다.
			print_n_times("안녕하세요")
			
			==> 실행 결과
				안녕하세요
				안녕하세요
				
	5-1-5. 키워드 매개변수
		기본 매개변수에 값을 '직접' 입력하는 매개변수
		예 ]
			def print_n_times(*values, n=2):
				# n번 반복합니다.
				for i in range(n):
					# values는 리스트처럼 활용합니다.
					for value in values:
						print(value)
					# 단순한 줄바꿈
					print()

			# 함수를 호출합니다.
			print_n_times("안녕하세요", "즐거운", "파이썬 프로그래밍", n=3)			<== 매개변수 n=2의 값을 n=3으로 '직접' 입력하여 바꾼다.
			
-------------------------------------------------------------------------------------------------------------------------------------------------------
참고 ] 기본 매개변수 중에서 필요한 값만 입력하기
	def test(a, b=10, c=100):
		print(a + b + c)

	# 1) 기본 형태
	test(10, 20, 30)
	# 2) 키워드 매개변수로 모든 매개변수를 지정한 형태
	test(a=10, b=100, c=200)
	# 3) 키워드 매개변수로 모든 매개변수를 마구잡이로 지정한 형태
	test(c=10, a=100, b=200)
	# 4) 키워드 매개변수로 일부 매개변수만 지정한 형태
	test(10, c=200)

	==> 실행결과 ]
		60
		310
		310
		220

	- 1) a는 일반 매개변수이므로 해당 위치에 반드시 입력해야 하고, 일반 매개변수이지만 키워드 매개변수처럼 사용할 수 있다.
	- 3) 키워드를 지정해서 매개변수를 입력하는 경우 매개변수 순서를 원하는 대로 입력할 수 있다.


참고 ] 파이썬 라이브러리 사이트
	https://docs.python.org/3/library/index.html
	
	5-1-6. 리턴
		- 자료 없이 리턴하기	: return
		- 자료와 함께 리턴하기	: return 100, return "리턴하기"
		
		* 아무 것도 리턴하지 않았을 때(return) 리턴값은 None 이다
		
	5-1-7. 기본적인 함수의 활용
		def 함수(매개변수):
			변수 = 초깃값
			# 여러 가지 처리
			# 여러 가지 처리
			# 여러 가지 처리
			return 변수
			
===================================================================================================================

----------------------------------------------------------------------------------------
5-2. 함수의 활용

5-2-1. 재귀 함수
	< 반복문으로 팩토리얼 구하기 >
	# 함수를 선언합니다.
	def factorial(n):
		# 변수를 선언합니다.
		output = 1
		# 반복문을 돌려 숫자를 더합니다.
		for i in range(1, n + 1):
			output *= i
		# 리턴합니다.
		return output

	# 함수를 호출합니다.
	print("1!:", factorial(1))
	print("2!:", factorial(2))
	print("3!:", factorial(3))
	print("4!:", factorial(4))
	print("5!:", factorial(5))

	==> 실행 결과
	1!: 1
	2!: 2
	3!: 6
	4!: 24
	5!: 120

	< 재귀 함수로 팩토리얼 구하기 >
	factorial(n) = n * factorial(n-1) (n >= 1 일 때)
	factorial(0) = 1
	을 이용한다.

		# 함수를 선언합니다.
		def factorial(n):
			# n이 0이라면 1을 리턴
			if n == 0:
				return 1
			# n이 0이 아니라면 n * (n-1)!을 리턴
			else:
				return n * factorial(n - 1)

		# 함수를 호출합니다.
		print("1!:", factorial(1))
		print("2!:", factorial(2))
		print("3!:", factorial(3))
		print("4!:", factorial(4))
		print("5!:", factorial(5))

	주의 ] 재귀 함수의 문제
		불필요한 연산까지 반복하게 되어 연산 속도가 매우 느려질 수 있음.

		예 ] 피보나치 수열 구현
			# 변수를 선언합니다.
			counter = 0

			# 함수를 선언합니다.
			def fibonacci(n):
				# 어떤 피보나치 수를 구하는지 출력합니다.
				print("fibonacci({})를 구합니다.".format(n))
				global counter
				counter += 1
				# 피보나치 수를 구합니다.
				if n == 1:
					return 1
				if n == 2:
					return 1
				else:
					return fibonacci(n-1) + fibonacci(n-2)

			# 함수를 호출합니다.
			fibonacci(10)
			print("---")
			print("fibonacci(10) 계산에 활용된 덧셈 횟수는 {}번 입니다.".format(counter))

			==> 피보나치수열 10을 구하기 위해 무려 109번을 연산함.

			참고 ] global 키워드
				파이썬은 함수 내부에서 함수 외부에 있는 변수를 참조하지 못하며
				이 때 UnboundLocalError가 발생한다.
				이를 해결해주는 것이 global 키워드이다.
	
	< 해결 방법 : 메모화 >
	딕셔너리를 사용해서 한 번 계산한 값을 저장한다.
	예 ]
		# 메모 변수를 만듭니다.
		dictionary = {
			1: 1,
			2: 1
		}
 
		# 함수를 선언합니다.
		def fibonacci(n):
			if n in dictionary:
				# 메모가 되어 있으면 메모된 값을 리턴
				return dictionary[n]
			else:
				# 메모가 되어 있지 않으면 값을 구함
				output = fibonacci(n-1) + fibonacci(n-2)
				dictionary[n] = output
				return output	# 조기 리턴

		# 함수를 호출합니다.
		print("fibonacci(10):", fibonacci(10))
		print("fibonacci(20):", fibonacci(20))
		print("fibonacci(30):", fibonacci(30))
		print("fibonacci(40):", fibonacci(40))
		print("fibonacci(50):", fibonacci(50))

	< 조기 리턴 >
	프로그램의 흐름 중간에 return 키워드를 사용하는 것

--------------------------------------------------------------------------------------------------------------------------
5-3. 함수 고급
- 튜플 : 리스트와 비슷하지만 한 번 결정된 요소는 바꿀 수 없음
- 람다 : 매개변수를 전달하기 위해 함수 구문을 작성하는 것이 번거롭고, 코드 공간 낭비라는 생각이 들 때
		 함수를 간단하고 쉽게 선언하는 방법

5-3-1. 튜플
	(데이터, 데이터, 데이터 ...)

	예 ]
		>>> tuple_test = (10, 20, 30)
		>>> tuple_test[0]            
		10  
		>>> tuple_test[1] 
		20
		>>> tuple_test[0] = 1
		==> 에러 발생..!! 한 번 결정된 요소 변경 불가

	참고 ] 요소를 하나만 가지는 튜플을 선언할 때
		리스트는 [273]이면 되지만
		튜플은 (273)일 경우 에러 발생
		(273, )으로 표기해야 함

	참고 ] 괄호 없는 튜플
		- 리스트와 튜플은 다음과 같이 사용해도 된다.
			# 리스트와 튜플의 특이한 사용
			[a, b] = [10, 20]
			(c, d) = (10, 20)

			# 출력합니다.
			print("a:", a)
			print("b:", b)
			print("c:", c)
			print("d:", d)
			==>	결과
				a: 10
				b: 20
				c: 10
				d: 20

		- 괄호를 생략해도 튜플로 인식할 수 있는 경우는 괄호를 생략해도 됨
			# 괄호가 없는 튜플
			tuple_test = 10, 20, 30, 40
			print("# 괄호가 없는 튜플의 값과 자료형 출력")
			print("tuple_test:", tuple_test)
			print("type(tuple_test):", type(tuple_test))
			print()

			# 괄호가 없는 튜플 활용
			a, b, c = 10, 20, 30
			print("# 괄호가 없는 튜플을 활용한 할당")
			print("a:", a)
			print("b:", b)
			print("c:", c)
			==> 실행 결과
				# 괄호가 없는 튜플의 값과 자료형 출력
				tuple_test: (10, 20, 30, 40)
				type(tuple_test): <class 'tuple'>

				# 괄호가 없는 튜플을 활용한 할당
				a: 10
				b: 20
				c: 30

	참고 ] 튜플을 리턴하는 함수의 예
		divmod() 함수 : 매개변수를 나머지 연산해서 몫과 나머지를 튜플 형태로 리턴한다.
		예 ]
			>>> a, b = 97, 40
			>>> a // b
			2   
			>>> a % b
			17  
			>>> divmod(a, b)
			(2, 17)
------------------------------------------------------------------------------------------------------------------------
3-5-2. 람다
함수라는 '기능'을 매개변수로 전달하는 코드를 작성하기 위해 자주 사용되는 기능

	< 함수의 매개변수로 함수 전달하기 >
	# 매개변수로 받은 함수를 10번 호출하는 함수
	def call_10_times(func):
		for i in range(10):
			func()

	# 간단한 출력하는 함수
	def print_hello():
		print("안녕하세요")

	# 조합하기
	call_10_times(print_hello)
	==> '안녕하세요' 10번 출력

	< filter() 함수와 map() 함수 >
		- map(함수, 리스트) : 리스트의 요소를 함수에 넣고 리턴된 값으로 새로운 리스트를 구성해 주는 함수
		- filter(함수, 리스트) : 리스트의 요소를 함수에 넣고 리턴된 값이 True인 것으로 새로운 리스트를 구성해주는 함수
		예 ]
			# 함수를 선언합니다.
			def power(item):
				return item * item
			def under_3(item):
				return item < 3

			# 변수를 선언합니다.
			list_input_a = [1, 2, 3, 4, 5]

			# map()함수를 사용합니다.
			output_a = map(power, list_input_a)
			print("# map() 함수의 실행결과")
			print("map(power, list_input_a):", output_a)
			print("map(power, list_input_a):", list(output_a))
			print()

			# filter() 함수를 사용합니다.
			output_b = filter(under_3, list_input_a)
			print("# filter() 함수의 실행결과")
			print("filter(under_3, list_input_a):", output_b)
			print("filter(under_3, list_input_a):", list(output_b))
			==> 실행결과
				# map() 함수의 실행결과
				map(power, list_input_a): <map object at 0x000001E04A3D3FA0>
				map(power, list_input_a): [1, 4, 9, 16, 25] -> 제곱 결과리스트 출력

				# filter() 함수의 실행결과
				filter(under_3, list_input_a): <filter object at 0x000001E04A3D3EB0>
				filter(under_3, list_input_a): [1, 2] -> 3보다 작다는 조건에 맞는 결과리스트 출력
------------------------------------------------------------------------------------------------------------------------	
	< 람다의 개념 >
	lambda 매개변수: 리턴값

	예 ] 앞의 map()과 filter() 함수에서 쓰인 예제에서 함수 부분만 바꿈
		# 함수를 선언합니다.
		power = lambda x: x * x
		under_3 = lambda x: x < 3

	예 ] 인라인 람다
		# 변수를 선언합니다.
		list_input_a = [1, 2, 3, 4, 5]

		# map()함수를 사용합니다.
		output_a = map(lambda x: x * x, list_input_a)		# 선언과 즉시 사용가능
		print("# map() 함수의 실행결과")
		print("map(power, list_input_a):", output_a)
		print("map(power, list_input_a):", list(output_a))
		print()

		# filter() 함수를 사용합니다.
		output_b = filter(lambda x: x < 3, list_input_a)	# 선언과 즉시 사용가능
		print("# filter() 함수의 실행결과")
		print("filter(under_3, list_input_a):", output_b)
		print("filter(under_3, list_input_a):", list(output_b))

	참고 ] 다음과 같이 매개변수가 여러 개인 람다도 만들 수 있다.
		lambda x, y: x * y

---------------------------------------------------------------------------------------------------------------------
3-5-3. 파일 처리
	< 파일 열고 닫기 >
		1) 파일 열 때: open()
			파일 객체 = open(문자열: 파일 경로, 문자열: 읽기 모드)

			* 읽기 모드 옵션
			- w : write 모드(세로 쓰기 모드)
			- a : append 모드(뒤에 이어서 쓰기 모드)
			- r : read 모드(읽기 모드)

		2) 파일 닫을 때: close()
			파일 객체.close()
			==> 반드시 close()로 닫는 습관 들이기
		예 ]
			# 파일을 엽니다.
			file = open("doc/basic.txt", "w")

			# 파일에 텍스트를 씁니다.
			file.write("Hello Python Programming...!")

			# 파일을 닫습니다.
			file.close()

	< with 키워드 >
		파일을 열고 닫지 않는 실수를 방지하기 위해 만들어진 키워드
			with open(문자열: 파일 경로, 문자열: 읽기 모드) as 파일 객체:
				문장
		==> with 구문이 종료될 때 자동으로 파일이 닫힘
		==> with 키워드는 네트워크로 흐르는 길을 열고 닫을 때에도 사용한다.

	< 텍스트 읽기 > 
		파일 객체.read()
		==> 파일 내부의 데이터를 모두 읽어 출력함

	< 텍스트 한 줄씩 읽기 >
	for 한 줄을 나타내는 문자열 in 파일 객체:
		처리		
	
	예제 코드 ] 랜덤하게 1000명의 키와 몸무게 만들고 출력하기
		# 1. 1000명의 키와 몸무게 만들기
		# 파일을 엽니다.
		with open("doc/basic.txt", "r") as file:
			# 파일을 읽고 출력합니다.
			contents = file.read()
		print(contents)

		# 랜덤한 숫자를 만들기 위해 가져옵니다.
		import random

		# 간단한 한글 리스트를 만듭니다.
		hanguls = list("가나다라마바사아자차카타파하")
		# 파일을 쓰기 모드로 엽니다.
		with open("doc/info.txt", "w", encoding="UTF-8") as file:
			for i in range(1000):
				# 랜덤한 값으로 변수를 생성합니다.
				name = random.choice(hanguls) + random.choice(hanguls)
				weight = random.randrange(40, 100)
				height = random.randrange(140, 200)
				# 텍스트를 씁니다.
				file.write("{}, {}, {}\n".format(name, weight, height))

		# 2. 반복문으로 파일 한 줄씩 읽기
		with open("doc/info.txt", "r", encoding="UTF-8") as file:
		for line in file:
			# 변수를 선언합니다.
			(name, weight, height) = line.strip().split(", ")

			# 데이터가 문제없는지 확인합니다: 문제가 있으면 지나감
			if (not name) or (not weight) or (not height):
				continue
			# 결과를 계산합니다.
			bmi = int(weight) / ((int(height) / 100) **2)
			result = ""
			if 25 <= bmi:
				result = "과체중"
			elif 18.5 <= bmi:
				result = "정상 체중"
			else:
				result = "저체중"

			# 출력합니다.
			print('\n'.join([
				"이름: {}",
				"몸무게: {}",
				"키: {}",
				"BMI: {}",
				"결과: {}",
			]).format(name, weight, height, bmi, result))
			print()

	< writelines() 함수 >
		문자열 리스트를 매개변수로 받아서 파일에 입력해줌
		이 때 띄어쓰기 미반영

----------------------------------------------------------------------------------------------------------
* 제너레이터
	이터레이터를 '직접' 만들 때 사용하는 코드 (204쪽 또는 4.반복문.txt 참고)

	함수 내부에 'yield 키워드'를 사용하면 해당 함수는 제너레이터 함수가 되며, 일반 함수와는 달리 함수를 
	호출해도 함수 내부의 코드가 실행되지 않는다.
	
	예 ]
		# 함수를 선언합니다.
		def test():
			print("함수가 호출되었습니다.")
			yield "test"	# 함수 내부의 코드가 실행되지 않음

		# 함수를 호출합니다.
		print("A 지점 통과")
		test()

		print("B 지점 통과")
		test()
		print(test())
		==> 실행 결과

			A 지점 통과
			B 지점 통과
			<generator object test at 0x000001C16100BBA0>

	제너레이터 객체는 next() 함수를 사용해 함수 내부의 코드를 실행합니다.
	이 때 yield 키워드 부분까지만 실행하며 next() 함수의 리턴값으로 yield 키워드 뒤에 입력한 값이 출력된다.
	
	예 ]
		# 함수를 선언합니다.
		def test():
			print("A 지점 통과")
			yield 1
			print("B 지점 통과")
			yield 2
			print("C 지점 통과")
		# 함수를 호출합니다.
		output = test()
		# next() 함수를 호출합니다.
		print("D 지점 통과")
		a = next(output)
		print(a)
		print("E 지점 통과")
		b = next(output)
		print(b)
		print("F 지점 통과")
		c = next(output)
		print(c)
		# 한 번 더 실행하기
		next(output)
		==> 실행 결과

			D 지점 통과
			A 지점 통과
			1
			E 지점 통과
			B 지점 통과
			2
			F 지점 통과
			C 지점 통과
			Traceback (most recent call last):
			File "d:\python\source\day05.py", line 529, in <module>
				c = next(output)
			StopIteration	# next() 함수를 호출한 이후 yield 키워드를 만나지 못하고 함수가 끝나면 StopIteration이라는 예외 발생
		
	* 미션 : reversed 함수를 제너레이터로 구현해보기